import { MCPPortalServer } from '../../mcp-server';
import { SwaggerLoader } from '../../core/SwaggerLoader';
import { Authentication } from '../../core/Authentication';
import { Logger } from '../../logging/Logger';

// Mock the dependencies
jest.mock('../../core/SwaggerLoader');
jest.mock('../../core/Authentication');
jest.mock('../../logging/Logger');
jest.mock('@modelcontextprotocol/sdk/server/index.js');
jest.mock('@modelcontextprotocol/sdk/server/stdio.js');

const MockedSwaggerLoader = SwaggerLoader as jest.MockedClass<typeof SwaggerLoader>;
const MockedAuthentication = Authentication as jest.MockedClass<typeof Authentication>;
const MockedLogger = Logger as jest.MockedClass<typeof Logger>;

describe.skip('MCPPortalServer', () => {
  let server: MCPPortalServer;
  let mockLogger: jest.Mocked<Logger>;
  let mockSwaggerLoader: jest.Mocked<SwaggerLoader>;
  let mockAuth: jest.Mocked<Authentication>;

  beforeEach(() => {
    jest.clearAllMocks();

    // Mock Logger
    mockLogger = {
      info: jest.fn(),
      error: jest.fn(),
      warn: jest.fn(),
      debug: jest.fn(),
    } as any;
    MockedLogger.mockImplementation(() => mockLogger);

    // Mock SwaggerLoader
    mockSwaggerLoader = {
      loadSpec: jest.fn(),
    } as any;
    MockedSwaggerLoader.mockImplementation(() => mockSwaggerLoader);

    // Mock Authentication
    mockAuth = {
      getAuthHeaders: jest.fn(),
      hasApiKey: jest.fn(),
    } as any;
    MockedAuthentication.mockImplementation(() => mockAuth);
  });

  describe('constructor', () => {
    it('should initialize the server with default configuration', () => {
      server = new MCPPortalServer();

      expect(MockedLogger).toHaveBeenCalledWith('info');
      expect(MockedSwaggerLoader).toHaveBeenCalledWith(
        'https://api.portaldatransparencia.gov.br/swagger-ui/swagger.json',
        mockLogger
      );
      expect(MockedAuthentication).toHaveBeenCalledWith({}, mockLogger);
    });

    it('should configure authentication with API key when provided', () => {
      process.env.PORTAL_API_KEY = 'test-api-key';

      server = new MCPPortalServer();

      expect(MockedAuthentication).toHaveBeenCalledWith({ apiKey: 'test-api-key' }, mockLogger);

      delete process.env.PORTAL_API_KEY;
    });

    it('should configure logger with LOG_LEVEL environment variable', () => {
      process.env.LOG_LEVEL = 'debug';

      server = new MCPPortalServer();

      expect(MockedLogger).toHaveBeenCalledWith('debug');

      delete process.env.LOG_LEVEL;
    });
  });

  describe('initialize', () => {
    beforeEach(() => {
      server = new MCPPortalServer();
    });

    it('should load swagger spec and generate tools successfully', async () => {
      const mockSpec = {
        paths: {
          '/test': {
            get: {
              operationId: 'testOperation',
              summary: 'Test operation',
              parameters: [],
            },
          },
        },
      };

      mockSwaggerLoader.loadSpec.mockResolvedValue(mockSpec as any);

      await server.initialize();

      expect(mockLogger.info).toHaveBeenCalledWith(
        'Iniciando carregamento da especificação Swagger...'
      );
      expect(mockSwaggerLoader.loadSpec).toHaveBeenCalled();
      expect(mockLogger.info).toHaveBeenCalledWith('Especificação carregada com sucesso');
      expect(mockLogger.info).toHaveBeenCalledWith(
        expect.stringContaining('ferramentas MCP geradas com sucesso')
      );
    });

    it('should handle initialization errors', async () => {
      const error = new Error('Failed to load spec');
      mockSwaggerLoader.loadSpec.mockRejectedValue(error);

      await expect(server.initialize()).rejects.toThrow('Failed to load spec');

      expect(mockLogger.error).toHaveBeenCalledWith('Falha ao inicializar servidor MCP', {
        error: 'Failed to load spec',
      });
    });

    it('should handle unknown error types', async () => {
      const error = 'String error';
      mockSwaggerLoader.loadSpec.mockRejectedValue(error);

      await expect(server.initialize()).rejects.toBe(error);

      expect(mockLogger.error).toHaveBeenCalledWith('Falha ao inicializar servidor MCP', {
        error: 'String error',
      });
    });
  });

  describe('tool generation', () => {
    beforeEach(() => {
      server = new MCPPortalServer();
    });

    it('should generate tools from swagger specification', async () => {
      const mockSpec = {
        paths: {
          '/viagens': {
            get: {
              operationId: 'getViagensUsingGET',
              summary: 'Lista viagens',
              parameters: [
                {
                  name: 'ano',
                  in: 'query',
                  required: true,
                  schema: { type: 'integer' },
                },
              ],
            },
          },
          '/contratos/{id}': {
            get: {
              operationId: 'getContratoUsingGET',
              summary: 'Busca contrato por ID',
              parameters: [
                {
                  name: 'id',
                  in: 'path',
                  required: true,
                  schema: { type: 'string' },
                },
              ],
            },
          },
        },
      };

      mockSwaggerLoader.loadSpec.mockResolvedValue(mockSpec as any);

      await server.initialize();

      // Verify tools were generated
      expect(mockLogger.info).toHaveBeenCalledWith(
        expect.stringContaining('2 ferramentas MCP geradas com sucesso')
      );
    });

    it('should skip invalid operations', async () => {
      const mockSpec = {
        paths: {
          '/test': {
            get: {
              // Missing operationId - should be skipped
              summary: 'Test operation',
            },
            post: {
              operationId: 'validOperation',
              summary: 'Valid operation',
            },
          },
        },
      };

      mockSwaggerLoader.loadSpec.mockResolvedValue(mockSpec as any);

      await server.initialize();

      // Should only generate 1 tool (the valid one)
      expect(mockLogger.info).toHaveBeenCalledWith(
        expect.stringContaining('1 ferramentas MCP geradas com sucesso')
      );
    });
  });

  describe('error handling', () => {
    beforeEach(() => {
      server = new MCPPortalServer();
    });

    it('should handle swagger spec without paths', async () => {
      const mockSpec = { info: { title: 'Test', version: '1.0' } };
      mockSwaggerLoader.loadSpec.mockResolvedValue(mockSpec as any);

      await expect(server.initialize()).rejects.toThrow('Especificação Swagger inválida');
    });
  });
});
